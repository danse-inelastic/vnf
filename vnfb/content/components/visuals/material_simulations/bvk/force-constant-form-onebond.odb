# -*- Python -*-
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#                                 Jiao Lin
#                      California Institute of Technology
#                      (C) 2006-2009  All Rights Reserved
#
# {LicenseText}
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#


import luban.content as lc
from luban.content import select, load, alert
from luban.content.FormSelectorField import FormSelectorField
from luban.content.FormTextField import FormTextField


mat0 = [
    [0,0,0],
    [0,0,0],
    [0,0,0],
    ]


def visual(
    uid, sites,
    siteA=0, siteB=0, siteBlatticevector=[0,0,0],
    editable = True,
    bondiseditable=False,
    matrix=mat0, constraints=[],
    ):
    
    doc = lc.splitter(Class='force-constant-form-one-bond')

    left = doc.section()
    right = doc.section()

    bonddoc = bondWidget(
        uid, sites,
        siteA=siteA, siteB=siteB, siteBlatticevector=siteBlatticevector,
        editable=editable and bondiseditable)
        
    left.add(bonddoc)
    
    grid = matrixdoc(uid, matrix, constraints, editable)
    right.add(grid)
    return doc


def matrixdoc(uid, matrix, constraints, editable):
    grid = lc.document(Class='grid', title='Force constant matrix')

    # find those that depends on others
    if editable and constraints:
        import numpy
        dependents = numpy.zeros((3,3), bool)
        for constraint in constraints:
            dependents[constraint.right.indexes] = 1
            continue

    # create input fields
    minputs = []
    for i in range(3):

        if not editable:
            deps = [1,1,1]
        else:
            if constraints: deps = dependents[i]
            else: deps = None

        vec = matrix[i]
        
        vecinputs, fields = vectorInput('%s-%s' % (uid, i), vec, deps)
        grid.add(vecinputs)

        minputs.append(fields)
        continue

    if editable and constraints is not None:
        for constraint in constraints:
            assert constraint.__class__.__name__.lower() == 'equal'
            left = constraint.left.indexes
            right = constraint.right.indexes
            i,j = left
            minputs[i][j].onchange = select(id=minputid(uid, right)).setAttr(
                text=select(id=minputid(uid, left)).getAttr('value'))
    
    return grid


def bondWidget(uid, sites, siteA, siteB, siteBlatticevector, editable=False):
    doc = lc.document(title='bond', Class='bond-container')
    sp = doc.splitter(Class='bond-sites')

    left = sp.section()
    sp.section().paragraph(text=['---'], Class='bond-sign')
    right = sp.section()

    wA = siteWidget(sites, siteA, 'siteA', editable)
    left.document(title='A').add(wA)
    
    wB = siteWidget(sites, siteB, 'siteB', editable)
    right.document(title='B').add(wB)

    v = siteBLatticeVectorDoc(uid, siteBlatticevector, editable)
    doc.add(v)

    return doc


def siteWidget(sites, siteindex, name, editable):
    if editable:
        opts = enumerate(sites)
        return FormSelectorField(
            tip = 'select site',
            name = 'siteB',
            entries = opts,
            selection = siteindex,
            )
    return lc.paragraph(text=[sites[siteindex]], Class='value')


def siteBLatticeVectorDoc(uid, vec, editable=False):
    doc = lc.document(
        title='Lattice vector added to siteB',
        Class='siteB-lattice-vector-container')

    if editable:
        doc.add(siteBLatticeVectorInput(uid, vec))
    else:
        a,b,c = vec
        vtxt = "%s * a + %s * b + %s * c" % (a,b,c)
        doc.paragraph(text=[vtxt], Class='value')
    return doc


def siteBLatticeVectorInput(uid, vec=None):
    if vec is None:
        vec = [0,0,0]
        
    doc = lc.document()
    
    lvs = ['a', 'b', 'c']
    for i, (val, lv) in enumerate(zip(vec, lvs)):
        f = FormTextField(
            label = '',
            name = 'vector-%s' % lv,
            value = val,
            )
        doc.add(f)
        text = ['*', lv]
        if i<2: text.append(',')
        doc.paragraph(text=text)

    return doc


def minputid(uid, indexes):
    i,j = indexes
    return '%s-%s-%s' % (uid, i,j)


def vectorInput(uid, vec=None, deps=None):
    splitter = lc.splitter()
    fields = []
    for i in range(3):
        id = '%s-%s' % (uid, i)
        if deps is not None and deps[i]:
            f = lc.paragraph(id=id, Class='value')
            if vec: f.text = [vec[i]]
        else:
            f = FormTextField(id=id)
            if vec: f.value = vec[i]
            
        fields.append(f)
        splitter.section().add(f)
        
        continue
    
    return splitter, fields


# version
__id__ = "$Id$"

# End of file 
