#!/usr/bin/env python
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#                                 Jiao Lin
#                      California Institute of Technology
#                      (C) 2006-2009  All Rights Reserved
#
# {LicenseText}
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#


from luban.content import load, select

from luban.content.Document import Document
from luban.content.Link import Link


from luban.components.Actor import Actor as base


class Actor(base):


    class Inventory(base.Inventory):

        import pyre.inventory

        id = pyre.inventory.str('id')

        matter_type = pyre.inventory.str('matter_type')
        matter_id = pyre.inventory.str('matter_id')

        short_description = pyre.inventory.str('short_description', default = '' )
        short_description.meta['tip'] = 'A short description'
        
        librarycontent = pyre.inventory.str('librarycontent')
        inputFileContents = pyre.inventory.str('inputFileContents')
        runtype = pyre.inventory.str('runtype')
        
        creator = pyre.inventory.str('creator')
        description = pyre.inventory.str('description')
        potential_name = pyre.inventory.str('potential_name')
        potential_filename = pyre.inventory.str('potential_filename')
        
#        engine = pyre.inventory.str('engine', default='vasp')
#        engine.validator=pyre.inventory.choice(['vasp', 'ab init'])
#        engine.meta['tip'] = 'Ab initio engine'
#        
#        xcFunctional = pyre.inventory.str('xcFunctional', default='PAW-PBE')
#        xcFunctional.meta['tip'] = 'Exchange correlation functional'
#        
#        kineticEnergyCutoff = pyre.inventory.float('kineticEnergyCutoff', default=140.0)
#        kineticEnergyCutoff.meta['tip'] = 'Kinetic energy cutoff'
#
#        #monkhorstPackMesh.meta['tip'] = 'Monkhorst pack mesh'
#        nKx = pyre.inventory.int('nKx')
#        nKy = pyre.inventory.int('nKy')
#        nKz = pyre.inventory.int('nKz')


    def start(self, director):
        assert self.inventory.id == ''

        matter = self._getMatter(director)
        matterlabel = matter.short_description or matter.chemical_formula or matter.id
        title = 'Forcefield simulation of %s' % (matterlabel,)
        wizard = Document(id='forcefieldwizard-start', title=title)

        link = Link(label='back to Matter\ %s' % matterlabel)
        link.onclick = load(
            actor='matter', routine='showMaterialView',
            id=matter.id, type=matter.name)
        wizard.add(link)
        
        form = self.startform(director)
        wizard.add(form)
        
        return select(id='main-display-area').replaceContent(wizard)


    def restart(self, director):
        id = self.inventory.id
        assert id

        simulation = self._getSimulation(director)
        matter = simulation.matter.dereference(director.clerk.db)
        
        matterlabel = matter.short_description or matter.chemical_formula or matter.id
        title = 'Simulation\ %s: Forcefield simulation of Matter\ %s' % (id, matterlabel)
        wizard = Document(id='forcefieldwizard-start', title=title)

        link = Link(label='back to Matter\ %s' % matterlabel)
        link.onclick = load(
            actor='matter', routine='showMaterialView',
            id=matter.id, type=matter.name)
        wizard.add(link)
        
        form = self.startform(director)
        wizard.add(form)
        
        return select(id='main-display-area').replaceContent(wizard)


    def startform(self, director):

        id = self.inventory.id
        if id:
            record = self._getSimulation(director)
            type = self.inventory.type = record.name
        else:
            record = GulpSimulation()
            type = self.inventory.type = 'gulpsimulations'
        
        from luban.content.Splitter import Splitter
        from luban.content.Form import Form
        from luban.content.FormTextField import FormTextField
        from luban.content.FormSelectorField import FormSelectorField
        
        form = Form(
            id='forcefield-wizard-startform',
            title='')

#        short_description = form.text(
#            id='short_description-input',
#            name='short_description',
#            label='Name of this calculation',
#            value = record.short_description)
#
#        subdoc = form.document(
#            id='forcefield-wizard-start-form-settings-container',
#            title = 'Forcefield settings',
#            )
#
#        # drop down menu for abinitio engine: [vasp, (abinit)]
#        choices=['vasp', 'quantum espresso (comming soon)']
#
#        # temporary hack to disallowing access to vasp
#        blacklist = ['demo', 'reviewer']
#        if director.sentry.username in blacklist:
#            del choices[choices.index('vasp')]
#
#        entries=zip(choices,choices)
#
#        eng=str(record.engine)
#        engine = FormSelectorField(
#            id='engine-input',
#            name = 'engine',
#            entries = entries,
#            label = 'Electronic Structure Engine',
#            selection = eng)
#        subdoc.add(engine)
#
#        # drop down menu XC-functional type:
#        choices=[
#            'PAW-PBE', 
#            'PAW-GGA', 
#            'PAW-LDA',
#            'USPP-GGA',
#            'USPP-LDA',
#            ]
#        entries=zip(choices, choices)
#
#        xcFunctional = FormSelectorField(
#            id='xcFunctional-input',
#            name = 'xcFunctional',
#            entries = entries,
#            label = 'Exchange correlation functional',
#            selection = record.xcFunctional,
#            )
#        subdoc.add(xcFunctional)
#        
#        kineticEnergyCutoff = FormTextField(
#            id = 'kineticEnergyCutoff-input',
#            name='kineticEnergyCutoff',
#            label='Kinetic energy cutoff (eV)',
#            value = str(record.kineticEnergyCutoff))
#        subdoc.add(kineticEnergyCutoff)
#
#        box = Splitter(id='nkpts-container')
#        subdoc.add(box)
#        nKx = FormTextField(
#            id = 'nKx-input',
#            name='nKx',
#            label = 'Number of k-points (a*)',
#            value = str(record.monkhorstPackMesh[0]))
#        box.section().add(nKx)
#        nKy = FormTextField(
#            id = 'nKy-input',
#            name='nKy',
#            label = 'Number of k-points (b*)',
#            value = str(record.monkhorstPackMesh[1]))       
#        box.section().add(nKy)
#        nKz = FormTextField(
#            id = 'nKz-input',
#            name='nKz',
#            label = 'Number of k-points (c*)',
#            value = str(record.monkhorstPackMesh[2]))     
#        box.section().add(nKz)

#    def configureSimulation(self, director):
        
        #simulation = self._getSimulation(director)
        #id = self.inventory.id = simulation.id

        args = {
            'simulationId': id,
            'simulationType': type,
            'matterId':record.matter.id,
            #'coordinateType':simulation.matter.
            }
        callbackArgs = {
            'cgihome':director.cgihome,
            'sentry.username':director.sentry.username,
            'sentry.ticket':director.sentry.ticket,
#            'actor': self.name,
            }
        args.update(callbackArgs)
        
        from vnf.components.JnlpFile import JnlpFile
        jnlpFile = JnlpFile(
            resources=('GULP.jar', 'j2ssh.jar', 'commons-logging.jar','pg74.216.jdbc3.jar'),
            mainClass='javagulp.controller.LaunchGulpUi',
            programArguments = args,
            fileName='gulpLauncher',
            director=director
            )
        relativeLocationOfFile = jnlpFile.writeJnlp(director)
        
        p = form.paragraph()
        p.text = ['''The Gulp simulation package uses efficient forcefield
        techniques for simulating larger systems.  Its capabilities include forcefields from 
        a large number of trial functions, phonon / molecular dynamics / optimization, experimental data fitting,
        and crystal property calculation.  <br>''',
        '<center><a href="'+relativeLocationOfFile+'"><img src="images/webstart.gif" alt="GulpUi"/></a></center>']

        p = form.paragraph()
        p.text = ['''Press "Launch" above to activate GulpUi in Java Web Start mode.  Note: you must have
        a Java Virtual Machine (JVM) installed.  If you do not, clicking "Launch" will likely cause your browser to alert you to this
        and install one automatically.  It is highly recommended to use the JVM from Sun Microsystems.  The OpenJDK (default on Ubuntu OS)
        does not work due to bugs in their webstart launcher.''']

        action = actionRequireAuthentication(
            label = 'Continue',
            sentry = director.sentry,
            actor = 'gulpsimulationwizard', 
            routine = 'verifyConfiguration',
            id=id, type=type,
            )
        link = action_link(action, director.cgihome)

        p = form.paragraph()
        p.text = [link]

        next = form.submitbutton(label="next")
        
        from luban.content import select
        form.onsubmit = select(element=form).submit(
            actor = 'material_simulations/forcefieldwizard',
            routine = 'processStartForm',
            id = self.inventory.id,
            matter_type = self.inventory.matter_type,
            matter_id = self.inventory.matter_id,
            )
        
        return form


    def processStartForm(self, director):

        gulpSimulation = self._getSimulation(director)
        
        # make sure gulp simulation is configured
        if isConfigured(gulpSimulation, director):
            return self.readyForSubmission(director)
        return self.configureSimulation(director)

#        # should verify inputs here....
#        errors = {}
#        short_description = self.inventory.short_description
#        if not short_description:
#            errors['short_description'] = 'Description cannot be empty'
#        
#        if errors:
#            return self.startFormShowError(director, errors=errors)
#        
#        # store data
#        id = self.inventory.id
#        if id:
#            record = self._getSimulation(director)
#        else:
#            record = director.clerk.insertNewOwnedRecord(GulpSimulation)
#            matter = self._getMatter(director)
#            record.matter = matter
#        
#        props = [
#            'short_description',
#            'engine',
#            'xcFunctional',
#            'kineticEnergyCutoff',
#            ]
#        for prop in props:
#            value = getattr(self.inventory, prop)
#            setattr(record, prop, value)
#            continue
#
#        record.monkhorstPackMesh = [self.inventory.nKx, self.inventory.nKy, self.inventory.nKz]
#        director.clerk.updateRecordWithID(record)
#
#        return self.advancedConfiguration(director)


    def startFormShowError(self, director, errors=None):
        from luban.content import select
        return [
            select(id='%s-input' % name).showError(text)
            for name, text in errors.iteritems()
            ]


#    def advancedConfiguration(self, director):
#        document = Document(title='Ab initio electronic structure simulation: advanced configuration' )
#
#        simulation = self._getSimulation(director)
#        engine = simulation.engine
#        actor = 'material_simulations/%s-advanced' % engine.lower()
#        routine = 'start'
#        
#        return director.redirect(
#            actor=actor, routine=routine,
#            id=simulation.id)


    def _getMatter(self, director):
        return director.clerk.getRecordByID(
            self.inventory.matter_type, self.inventory.matter_id)

    
    def _getSimulation(self, director):
        return director.clerk.getRecordByID(GulpSimulation, self.inventory.id)
    

    def __init__(self, name='forcefieldwizard'):
        super(Actor, self).__init__(name)
        return
    
    
#class GulpSimulationWizard(MaterialSimulationWizard):


#    def verifyConfiguration(self, director):
#        try:
#            page = self._retrievePage(director)
#        except AuthenticationError, err:
#            return err.page
#
#        gulpSimulation = self._getSimulation(director)
#        
#        # make sure gulp simulation is configured
#        if isConfigured(gulpSimulation, director):
#            return self.readyForSubmission(director)
#        return self.configureSimulation(director)


    def readyForSubmission(self, director):
        try:
            page = self._retrievePage(director)
        except AuthenticationError, err:
            return err.page

        id = self.inventory.id
        type = self.inventory.type
        
        main = page._body._content._main
        document = main.document(title='Atomic-level Simulation with Forcefields' )

        p = document.paragraph()
        p.text = ['Your gulp simulation #%s is ready for submission.' % id]
        
        p = document.paragraph()
        action = actionRequireAuthentication(
            label = 'start',
            actor = 'gulpsimulationwizard', 
            sentry = director.sentry,
            routine = 'submitSimulation',
            id=id, type=type,
            )
        submit_link = action_link(action, director.cgihome)
        
        action = actionRequireAuthentication(
            label = 'save it for latter submission',
            actor = 'gulpsimulationwizard', 
            sentry = director.sentry,
            routine = 'saveSimulation',
            id=id, type=type,
            )
        save_link = action_link(action, director.cgihome)
        
        action = actionRequireAuthentication(
            label = 'delete',
            actor = 'gulpsimulationwizard', 
            sentry = director.sentry,
            routine = 'cancel',
            id=id, type=type,
            )
        delete_link = action_link(action, director.cgihome)

        p.text = [
            'You can %s this simulation, or %s, or %s it.' % (submit_link, save_link, delete_link),
            ]
        return page
        
    
    def storeInputFile(self, director):
        try:
            page = self._retrievePage(director)
        except AuthenticationError, err:
            return err.page

        inputFileContents = self.inventory.inputFileContents
        potential_name = self.inventory.potential_name
        
        simulation = self._getSimulation(director)
        from vnf.dom.GulpPotential import GulpPotential
        try:
            gulpPotential = director.clerk.getRecordByID(GulpPotential, self.inventory.potential_name, 
                associatedDataFileToVerify = self.inventory.potential_filename, director=director)
        except:
            return "failure--cannot find selected potential in database"
        
        #set simulation attributes
        simulation.runtype = self.inventory.runtype
        #potential = simulation.potential.dereference(director.clerk.db)
        simulation.potential = gulpPotential
        gulpPotential.potential_name = self.inventory.potential_name
        #director.clerk.updateRecord(potential)
        director.clerk.updateRecord(simulation)

        #create data directory for the simulation if necessary
        datadir = director.dds.abspath(simulation)
        if not os.path.exists(datadir): os.makedirs(datadir)

        inputFilePath = director.dds.abspath(simulation, filename=GulpSimulation.CONFIGURATION_FILE)
        open(inputFilePath, 'w').write(self.inventory.inputFileContents)
        
        #read the potential from the database
        potentialPath = director.dds.abspath(gulpPotential, filename=gulpPotential.filename)
        potentialContent = open(potentialPath).read()
        #write the potential in the simulation directory
        simulationPotential = director.dds.abspath(simulation, filename=gulpPotential.filename)
        open(simulationPotential, 'w').write(potentialContent)        

        return 'success'
    
    def storePotential(self, director):
        # quick hack to make sure we're authenticated
        try:
            page = self._retrievePage(director)
        except AuthenticationError, err:
            return err.page

        potential_filename = self.inventory.potential_filename
        librarycontent = self.inventory.librarycontent
        
        from vnf.dom.GulpPotential import GulpPotential
        try:
            gulpPotential = director.clerk.getRecordByID(GulpPotential, self.inventory.potential_name, 
                associatedDataFileToVerify = self.inventory.potential_filename, director=director)
        except:
            # if it doesn't exist, create a new one from this entry
            gulpPotential = director.clerk.newDbObject(GulpPotential, id = self.inventory.potential_name)
            gulpPotential.filename = potential_filename
            gulpPotential.creator = self.inventory.creator
            gulpPotential.description = self.inventory.description
            director.clerk.updateRecord(gulpPotential)
            
            #put the potential in the potentials subdirectory
            libfile = director.dds.abspath(gulpPotential, filename = potential_filename)
            libDirectory,file = os.path.split(libfile)
            if not os.path.exists(libDirectory):
                try:
                    os.makedirs(libDirectory)
                except Exception, err:
                    raise RuntimeError, "unable to create directory %r. %s: %s" % (
                        self.path, err.__class__.__name__, err)
            open(libfile, 'w').write(librarycontent)
            #server = director.clerk.dereference(job.server)
            director.dds.remember(gulpPotential, files=[potential_filename])#, server=server)

        return 'success'


import os
def isConfigured(sim, director):
    path = director.dds.abspath(sim, filename=GulpSimulation.CONFIGURATION_FILE)
    if os.path.exists(path): return True
    return False

from vnf.dom.GulpSimulation import GulpSimulation


def actor(): return Actor()


# version
__id__ = "$Id$"

# End of file 

