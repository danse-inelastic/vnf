#!/usr/bin/env python
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#                                  Jiao Lin
#                     California Institute of Technology
#                       (C) 2008  All Rights Reserved
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#


from vnf.components.MaterialSimulationWizard import \
     actionRequireAuthentication, action_link, \
     AuthenticationError, InputProcessingError
from vnf.weaver import action_href


from vnf.components.MaterialSimulationWizard import MaterialSimulationWizard as base


class QuantumEspressoWizard(base):
    
    
    class Inventory(base.Inventory):
        
        import pyre.inventory


    def configureSimulation(self, director):
        # self assert computation type
        type = self.inventory.type = 'abinitio'

        simulation = self._getSimulation(director)
        if not simulation:
            raise RuntimeError, '%s: %s' % (self.inventory.type, self.inventory.id)
        id = self.inventory.id = simulation.id

        # make sure material is defined
        if not self._materialDefinedForSimulation(simulation, director):
            return self._needMaterialAlert(director)

        # prepare page frame
        try:
            page = director.retrieveSecurePage( 'abinitiowizard' )
        except AuthenticationError, err:
            return err.page
        
        main = page._body._content._main
        document = main.document(title='Ab initio electronic structure simulation' )
        
        formcomponent = self.retrieveFormToShow( 'abinitio')
        formcomponent.director = director
        formcomponent.inventory.id = id
        # build the form form
        form = document.form(name='', action=director.cgihome)
        # specify action
        action = actionRequireAuthentication(          
            actor = 'abinitiowizard', 
            sentry = director.sentry,
            routine = 'verifyConfiguration',
            id=id, type=type,
            arguments = {'form-received': formcomponent.name },
            )
        from vnf.weaver import action_formfields
        action_formfields( action, form )
        # expand the form with fields of the data object that is being edited
        formcomponent.expand( form )
        next = form.control(name='submit',type="submit", value="next")
        return page


    def verifyConfiguration(self, director):
        try:
            page = self._retrievePage(director)
        except AuthenticationError, err:
            return err.page
        
        try:
            self.processFormInputs(director)
        except InputProcessingError, err:
            errors = err.errors
            self.form_received = None
            director.routine = 'configureSimulation'
            return self.configureSimulation( director, errors = errors )

        return self.advancedConfiguration(director)


    def advancedConfiguration(self, director, errors=None):
        try:
            page = self._retrievePage(director)
        except AuthenticationError, err:
            return err.page

        main = page._body._content._main
        document = main.document(title='Ab initio electronic structure simulation: advanced configuration' )

        simulation = self._getSimulation(director)
        engine = simulation.engine
        handler = '_advanced%s' % engine.upper()
        handler = getattr(self, handler)
        handler(document, director, errors=errors)

        return page


    def _advancedVASP(self, document, director, errors=None):
        id = self.inventory.id
        type = self.inventory.type

        computation = self._getSimulation(director)
        if self._vaspRawInputFilesExists(computation, director):
            rawInputs = self._readVaspRawInputFIles(computation, director)
            
            formcomponent = self.retrieveFormToShow( 'vasp-advanced')
            formcomponent.director = director
            
            # build the form 
            form = document.form(name='', action=director.cgihome)
            # specify action
            action = actionRequireAuthentication(          
                actor = 'abinitiowizard', 
                sentry = director.sentry,
                routine = 'verifyAdvancedVASPConfiguration',
                id=id, type=type,
                arguments = {'form-received': formcomponent.name },
                )
            from vnf.weaver import action_formfields
            action_formfields( action, form )

            # expand the form with fields from the form component
            formcomponent.expand(form, **rawInputs)
            next = form.control(name='submit',type="submit", value="next")

            p = document.paragraph()
            action = actionRequireAuthentication(
                label = 'skip',
                actor = 'abinitiowizard',
                sentry = director.sentry,
                routine = 'createJob',
                id = id, type = type,
                )
            link = action_link(action, director.cgihome)
            p.text = [
                'You can %s this step.' % link,
                ]
            return

        # the itask worker
        iworker = 'build-vasp-input-files'

        # first check if there is itask running
        found = None
        pending_tasks = computation.pending_tasks.dereference(director.clerk.db)
        if pending_tasks:
            for label, task in pending_tasks:

                # if not the right task, skip
                if task.worker != iworker: continue

                if task.state == 'finished':
                    raise RuntimeError, "Task %s for %s finished but no vasp inputs available." % (task.id, computation.id)

                if task.state == 'failed':
                    self._debug.log("Task %s for %s found. Which has failed before." % (task.id, computation.id))
                    # reopen the task
                    task.state = 'created'
                    director.clerk.updateRecord(task)
                    found = task
                    break

                if task.state == 'cancelled':
                    self._debug.log("Task %s for %s found. Which has been cancelled before." % (task.id, computation.id))
                    # reopen the task
                    task.state = 'created'
                    director.clerk.updateRecord(task)
                    found = task
                    break

                found = task
                break


        # if no previous task found, create a new task
        if not found:

            from vnf.dom.ITask import createITask, ITask
            task = director.clerk.newDbObject(ITask)
            task = createITask(
                task.id,
                beneficiary = computation,
                worker = iworker,
                type = iworker,
                )
            director.clerk.updateRecord(task)

            # add this task to pending task list
            computation.pending_tasks.add(task, director.clerk.db, name=iworker)

            found = task

        #
        task = found

        import vnf.content
        itaskmonitor = vnf.content.itaskMonitor(
            task.id,
            label = 'Generating raw VASP input files ...',
            sentry=director.sentry,
            )
        itaskmonitorid = itaskmonitor.id
        
        redirectaction = actionRequireAuthentication(
            sentry = director.sentry,
            label = '',
            actor = self.name,
            routine = 'advancedConfiguration',
            id = self.inventory.id,
            type = self.inventory.type,
            matterid = self.inventory.matterid,
            mattertype = self.inventory.mattertype,
            )
        redirecturl = action_href(redirectaction, director.cgihome)
        itaskmonitor.finished_callback = '''
  function(data) {
    var monitor = $("#%(itaskmonitorid)s");
    
    if (data.state=="finished") {
      monitor.text("Please wait for this page to reload...");
      window.location = "%(redirecturl)s";
    }
  }
''' % locals()
        document.add(itaskmonitor)

        import vnf.content
        snippet = vnf.content.jssnippet()
        snippet.main = [
            '$("#%s").itaskmonitor("start");' % itaskmonitor.id,
            ]
        document.add(snippet)
        return        


    def verifyAdvancedVASPConfiguration(self, director):
        try:
            page = self._retrievePage(director)
        except AuthenticationError, err:
            return err.page
        
        try:
            vaspInputs = self.processFormInputs(director)
        except InputProcessingError, err:
            errors = err.errors
            self.form_received = None
            director.routine = 'advancedConfiguration'
            return self.advancedConfiguration(director, errors = errors)

        # save user inputs as files
        simulation = self._getSimulation(director)
        #  create directory first
        dirpath = director.dds.abspath(simulation)
        import os
        if not os.path.exists(dirpath): os.makedirs(dirpath)
        #  create files
        for filename, content in vaspInputs.iteritems():
            path = director.dds.abspath(simulation, filename)
            open(path,'w').write(content)
            continue
        
        return self.createJob(director)


#<<<<<<< .mine
#    def _createVASPInputs(self, director):
#        # overall strategy: write files and then retrieve them and show to user
#        
#        # vasp computation configurations
#        simulation = self._getSimulation(director)
#
#        # make a copy of this computation
#        computation = director.clerk.deepcopy(simulation)
#        # change description
#        computation.short_description = 'generate vasp inputs for computation %s' \
#                                        % simulation.id
#        # make sure this computation only generate input files
#        computation.generateInputsOnly = True
#        director.clerk.updateRecord(computation)
#        
#        # create a job for this computation
#        from vnf.components.Job import new_job
#        job = new_job(director)
#
#        # connect this job to the computation
#        computation.job = job
#        director.clerk.updateRecord(computation)
#        job.computation = computation
#        director.clerk.updateRecord(job)
#        
#        # submit this job
#        from vnf.components.Job import submit
#        submit(job, director)
#
#        # the server this job was submitted to
#        server = job.server.dereference(director.clerk.db)
#        
#        # now wait and retrieve results
#        import time
#        time.sleep(1)
#        files = [
#            'INCAR',
#            'KPOINTS',
#            'POSCAR',
#            'POTCAR',
#            ]
#        
#        #  check whether input files were generated
#        #  try 10 times
#        count = 0; gotfiles = 0
#        while count<10:
#            count += 1
#            try:
#                director.dds.remember(job, files=files, server=server)
#                gotfiles = 1
#                break
#            except:
#                time.sleep(1)
#                continue
#        if not gotfiles:
#            raise RuntimeError, 'unable to generate VASP input files'
#
#        #  copy them to the vnf server
#        director.dds.make_available(job, files=files)
#
#        d = {}
#        for f in files:
#            d[f] = open(director.dds.abspath(job, f)).read()
#=======
    def _vaspRawInputFilesExists(self, computation, director):
        import os
        for f in VASP_RAW_INPUT_FILES:
            path = director.dds.abspath(computation, f)
            if not os.path.exists(path): return False
#>>>>>>> .r865
            continue
        return True
    

    def _readVaspRawInputFIles(self, computation, director):
        d = {}
        for f in VASP_RAW_INPUT_FILES:
            path = director.dds.abspath(computation, f)
            d[f] = open(path).read()
        return d


    def _readyForSubmission(self, director):
        if not base._readyForSubmission(self, director): return False
        simulation = self._getSimulation(director)
        if not simulation.short_description: return False
        return True
    

    def _retrievePage(self, director):
        return director.retrieveSecurePage( 'quantumespressowizard' ) 


    pass # end of AbinitioWizard


VASP_RAW_INPUT_FILES = [
    'pwscf.scf.in',
    ]

def actor():
    return QuanutmEspressoWizard('quantumespressowizard')


# version
__id__ = "$Id$"

# End of file 
