# -*- Python -*-
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#                                   Jiao Lin
#                      California Institute of Technology
#                        (C) 2008  All Rights Reserved
#
# {LicenseText}
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#


'''
A retriever is responsible to retrieve computation results from the data directory
for a computation job. The requirement of its public interface is:
methods:
  retrieve(self): retrieve results
  __init__(self, computation, director): ctor
  
The default retriever here make some assumptions that simplify the retrieval.
Subclasses of this retriever can implement much more sophisticated scheme to
retrieve results.

The assumption of this base retrieval is:

 1. computation will create a bunch of data files.
 2. each data file generated can be saved (by saving the meta data in
    a db record and the data file in the corresponding data directory
    of that db record.
'''


def all_results_exist(results, job, director):
    '''check if all computation results (data files) already exist.
    If yes that means the job is really successfully finished.

    results: data file names generated by the computation
    job: the job db record
    director: the director
    '''
    server = director.clerk.dereference(job.server)
    for r in results:
        if not director.dds.is_available(job, r, server): return False
        continue
    return True


class Retriever:

    def __init__(self, computation, director):
        self.computation = computation
        self.director = director
        return


    def _check_job_results_sanity(self, expected_results=None, job=None):
        '''check if the status of job results is sane

        expected_results: expected data files generated from computation
        job: the computation job db record
        '''
        director = self.director
        if isdone(job) and not all_results_exist(expected_results, job, director):
            raise RuntimeError, "job %s was done but not all expected results were generated"
        

    def _save_result(self, job,filenameinjobdir, recordtype,newfilename):
        '''save a computation result data file as a data file for a db record.

        job: the computation job db record
        filenameinjobdir: the data file name generated from the computation that was saved
            in the job data directory
        recordtype: the db table in which the result will be saved
        newfilename: the new data file name in the data directory of the result type.
            This indicates the new path the computation result will be saved
        '''
        #create a new record to save the result
        director = self.director
        record = director.clerk.newOwnedObject(recordtype, owner = job.creator)

        #make symbolic link from the result db record's data directory
        #to the job directory
        server = director.clerk.dereference(job.server)
        director.dds.move(job,filenameinjobdir, record,newfilename, server)

        # the result record should know where it comes from
        record.origin = self.computation
        director.clerk.updateRecord(record)

        # add the result to the result list
        self.computation.results.add(record, director.clerk.db, name=record.name)

        #
        self._mark_result_as_saved(job, filenameinjobdir)
        return


    def _mark_result_as_saved(self, job, filename):
        '''make a computation result filename as saved'''
        path = self.director.dds.abspath(job, '__saved__results__')

        # make sure directory exists
        dir = os.path.dirname(path)
        if not os.path.exists(dir): os.path.makedirs(dir)
                             
        f = open(path, 'a')
        f.write('%s\n' % filename)
        return

    def _is_result_saved(self, job, filename):
        '''check if a computation result filename was saved'''
        path = self.director.dds.abspath(job, '__saved__results__')
        if not os.path.exists(path): return False
        f = open(path)
        l = f.read().split('\n')
        return filename in l

    pass # end of Retriever


from vnf.components.Job import isdone
import os


# version
__id__ = "$Id$"

# End of file 
