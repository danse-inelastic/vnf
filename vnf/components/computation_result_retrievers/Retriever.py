# -*- Python -*-
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#                                   Jiao Lin
#                      California Institute of Technology
#                        (C) 2008  All Rights Reserved
#
# {LicenseText}
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#


'''
A retriever is responsible to retrieve computation results from the data directory
for a computation job. The requirement of its public interface is:
methods:
  retrieve(self): retrieve results
  __init__(self, computation, director): ctor
  
The default retriever here make some assumptions that simplify the retrieval.
Subclasses of this retriever can implement much more sophisticated scheme to
retrieve results.

The assumption of this base retrieval is:

 1. computation will create a bunch of data files.
 2. each data file generated can be saved (by saving the meta data in
    a db record and the data file in the corresponding data directory
    of that db record.
'''


def missing_results(results, job, director):
    '''check if all computation results (data files) already exist.
    return a list of results that are still missing.

    results: data file names that should be generated by the computation
    job: the job db record
    director: the director
    '''
    server = director.clerk.dereference(job.server)
    is_available = director.dds.is_available
    return filter(lambda f: not is_available(job, f, server), results)


class Retriever:

    def __init__(self, computation, director):
        self.computation = computation
        self.director = director
        return


    def _check_job_results_sanity(self, expected_results=None, job=None):
        '''check if the status of job results is sane

        expected_results: expected data files generated from computation
        job: the computation job db record
        '''
        director = self.director
        if isdone(job):
            missing = missing_results(expected_results, job, director)
            if missing:
                msg = "job %s was done but not all expected results were generated: %s" % (
                    job.id, missing)
                raise RuntimeError, msg
        return
    

    def _make_result_holder(self, job, table):
        '''make a result holder (a db record) for a
        
        For example, a bvk computation will create a dos data file, and it
        should be saved as a DOS data object. The result holder is then
        a record of the DOS db table. This function create a new db record
        of given db table.
        '''
        director = self.director
        record = director.clerk.newOwnedObject(table, owner = job.creator)
        # the result record should know where it comes from
        record.origin = self.computation
        director.clerk.updateRecord(record)
        return record
        

    def _save_result(self, job,filenameinjobdir, result_holder, newfilename):
        '''save a computation result data file as a data file for a db record.

        job: the computation job db record
        filenameinjobdir: the data file name generated from the computation that was saved
            in the job data directory
        result_holder: the db record in which the result will be saved
        newfilename: the new data file name in the data directory for the result holder.
            This indicates the new path the computation result will be saved
        '''
        #create a new record to save the result
        director = self.director

        #make copy 
        server = director.clerk.dereference(job.server)
        director.dds.copy(job,filenameinjobdir, result_holder,newfilename, server)

        # add the result to the result list
        self.computation.results.add(
            result_holder, director.clerk.db, name=result_holder.name)

        # 
        self._mark_result_as_saved(job, filenameinjobdir)
        return


    def _mark_result_as_saved(self, job, filename):
        '''make a computation result filename as saved'''
        path = self.director.dds.abspath(job, '__saved__results__')

        # make sure directory exists
        dir = os.path.dirname(path)
        if not os.path.exists(dir): os.path.makedirs(dir)
                             
        f = open(path, 'a')
        f.write('%s\n' % filename)
        return

    def _is_result_saved(self, job, filename):
        '''check if a computation result filename was saved'''
        path = self.director.dds.abspath(job, '__saved__results__')
        if not os.path.exists(path): return False
        f = open(path)
        l = f.read().split('\n')
        return filename in l

    pass # end of Retriever


from vnf.components.Job import isdone
import os


# version
__id__ = "$Id$"

# End of file 
