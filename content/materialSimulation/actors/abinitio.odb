#!/usr/bin/env python
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#                                 Jiao Lin
#                      California Institute of Technology
#                      (C) 2007-2008  All Rights Reserved
#
# {LicenseText}
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#


from vnf.components.FormActor import FormActor as base, action, actionRequireAuthentication, action_link, InputProcessingError, AuthenticationError


class Actor(base):
    
    class Inventory(base.Inventory):

        import pyre.inventory
        id = pyre.inventory.str( 'id', default = '')

    table = 'abinitio'

    def view(self, director):
        try:
            page = director.retrieveSecurePage( 'computation' )
        except AuthenticationError, err:
            return err.page

        id = self.inventory.id

        computation = director.clerk.getRecordByID(self.table, id)
        if not self._isConfigured(computation, director):
            actor = director.retrieveActor('abinitiowizard')
            director.configureComponent(actor)
            director.inventory.actor = director.actor = actor
            director.inventory.routine = director.routine = routine = 'start'
            actor.inventory.type = self.table
            actor.inventory.id = self.inventory.id
            return getattr(actor, routine)(director)

        main = page._body._content._main
        # populate the main column
        document = main.document(title='Ab initio simulation %s: %s' % (
            id, computation.short_description))

        job = director.clerk.dereference(computation.job)

        p = document.paragraph()
        action = actionRequireAuthentication(
            label = job.id,
            sentry = director.sentry,
            actor = 'job',
            routine = 'view',
            id = job.id,
            )
        link = action_link(action, director.cgihome)
        p.text = [
            'The computation job id for this simulation is %s' % link,
            ]

        configurationdoc = document.document(title='Configuration')
        self._view_configuration(computation, configurationdoc, director=director)

        if isdone(job):
            #if not computation.results_state or computation.results_state == 'retrieval failed':
            #retrieve_computation_results(computation, director, debug=0)
                
            resdoc = document.document(title='Results')
            p = resdoc.paragraph()
            action = actionRequireAuthentication(
                actor = self.name, sentry = director.sentry,
                label = 'here',
                routine = 'view_results',
                id = id,
                )
            link = action_link( action, director.cgihome )
            p.text = [
                'To see the results of this computation, please click %s' % link,
                ]

            further_computation_doc = document.document(title='More...')
            p = further_computation_doc.paragraph()
            action = actionRequireAuthentication(
                label = 'compute',
                sentry = director.sentry,
                actor = 'phononsfromabinitio', routine = 'create',
                abinitio_id = id,
                )
            link = action_link(action, director.cgihome)
            p.text = [
                'You can %s phonons from here now' % link,
                ]
        return page


    def view_results(self, director):
        try:
            page = director.retrieveSecurePage( 'computation' )
        except AuthenticationError, err:
            return err.page

        id = self.inventory.id
        computation = director.clerk.getRecordByID(self.table, id)

        main = page._body._content._main
        # populate the main column
        document = main.document(title='Ab initio simulation %s: results' % id)

        configurationdoc = document.document(title='Configuration')
        self._view_configuration(computation, configurationdoc, director=director)

        resultsdoc = document.document(title='Results')
        engine = computation.engine
        handler = '_view_%s_results' % engine
        handler = getattr(self, handler)
        handler(computation, resultsdoc, director=director)
        return page


    def _view_vasp_results(self, computation, document, director=None):
        self._view_vasp_dos(computation, document, director)
        return


    def _view_vasp_dos(self, computation, document, director):
        job = computation.job.dereference(director.clerk.db)
        
        from vnf.dom import VASP
        total_dos_dat = director.dds.abspath(job, VASP.total_electronic_dos_filename)

        import os
        if os.path.exists(total_dos_dat):
            dos = _readDOS(total_dos_dat)
            import vnf.content
            options = {}
            plot = vnf.content.plot_2d( dos, options )
            document.add( plot )
        else:
            # the itask worker
            iworker = 'retrieve-vasp-electronic-dos'
            
            # first check if there is itask running
            found = None
            pending_tasks = computation.pending_tasks.dereference(director.clerk.db)
            if pending_tasks:
                for label, task in pending_tasks:

                    # if not the right task, skip
                    if task.worker != iworker: continue

                    if task.state == 'finished':
                        raise RuntimeError, "Task %s for %s finished but no total dos available." % (task.id, computation.id)
                    
                    if task.state == 'failed':
                        self._debug.log("Task %s for %s found. Which has failed before." % (task.id, computation.id))
                        # reopen the task
                        task.state = 'created'
                        director.clerk.updateRecord(task)
                        found = task
                        break
                    
                    if task.state == 'cancelled':
                        self._debug.log("Task %s for %s found. Which has been cancelled before." % (task.id, computation.id))
                        # reopen the task
                        task.state = 'created'
                        director.clerk.updateRecord(task)
                        found = task
                        break

                    found = task
                    break
                

            # if no previous task found, create a new task
            if not found:
                
                from vnf.dom.ITask import createITask, ITask
                task = director.clerk.newDbObject(ITask)
                task = createITask(
                    task.id,
                    beneficiary = computation,
                    worker = iworker,
                    type = iworker,
                    )
                director.clerk.updateRecord(task)

                # add this task to pending task list
                computation.pending_tasks.add(task, director.clerk.db, name=iworker)
                
                found = task

            #
            task = found

            import vnf.content
            itaskmonitor = vnf.content.itaskMonitor(
                task.id,
                label = 'label',
                sentry=director.sentry,
                )
            itaskmonitor.finished_callback = '''
  function(data) {
    $("#%s").itaskmonitor("destroy");
    window.location.reload();
  }
''' % itaskmonitor.id
            document.add(itaskmonitor)

            import vnf.content
            snippet = vnf.content.jssnippet()
            snippet.main = [
                '$("#%s").itaskmonitor("start");' % itaskmonitor.id,
                ]
            document.add(snippet)
            
        return


    def _alertResultsNotFound(self, document, director):
        p = document.paragraph()
        p.text = [
            'Computation results not found',
            ]
        return 
        

    def _view_configuration(self, computation, document, director=None):
        engine = computation.engine
        handler = '_view_%s_configuration' % engine
        handler = getattr(self, handler)
        return handler(computation, document, director=director)


    def _view_vasp_configuration(self, computation, document, director=None):
        p = document.paragraph()
        p.text = [
            'Vasp simulation %s' % computation.id,
            ]

        matter = director.clerk.dereference(computation.matter)
        p = document.paragraph()
        p.text = [
            'Material: %s' % (matter.short_description,),
            ]

        p = document.paragraph()
        p.text = [
            'Kinetic energy cutoff: %s' % (computation.kineticEnergyCutoff,),
            ]

        p = document.paragraph()
        p.text = [
            'Exchange correlation functional: %s' % (computation.xcFunctional,),
            ]

        p = document.paragraph()
        p.text = [
            'Monkhorst pack messh: %s' % (computation.monkhorstPackMesh,),
            ]

        return


    def _isConfigured(self, computation, director):
        if not computation.short_description: return False
        if not computation.engine: return False
        if not computation.matter: return False
        if not computation.job: return False
        return True


def _readDOS(filename):
    f = open(filename)
    lines = f.readlines()
    E = []; I = []
    for line in lines:
        try:
            e, dos = line.split()
        except:
            continue

        e = float(e)
        dos = float(dos)
        
        E.append(e)
        I.append(dos)

        continue

    return E,I
        

def _readDOSCAR(doscar):
    try:
        efermi = _readEfermiFromDOSCAR(doscar)
    except:
        import journal, traceback
        journal.debug('vasp-dos').log(traceback.format_exc())
        return
    #quick hack for now
    f = open(doscar)
    lines = f.read().split('\n')
    E = []; I = []

    for line in lines[6:]:
        if not line: continue
        numbers = line.split()
        E.append(float(numbers[0])-efermi)
        I.append(float(numbers[1]))
        continue
    return E, I


def _readEfermiFromDOSCAR(doscar):
    f = open(doscar)
    for i in range(6): line = f.readline()
    words = line.split()
    assert len(words)==5
    return float(words[3])


from vnf.components.Job import isdone
from vnf.components.Computation import retrieve_results as retrieve_computation_results

def actor():
    return Actor('abinitio')


# version
__id__ = "$Id$"

# End of file 
