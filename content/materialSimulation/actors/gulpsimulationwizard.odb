#!/usr/bin/env python
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#                                  Jiao Lin
#                     California Institute of Technology
#                       (C) 2008  All Rights Reserved
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#


from vnf.components.MaterialSimulationWizard import \
     actionRequireAuthentication, action_link, AuthenticationError, InputProcessingError

from vnf.components.MaterialSimulationWizard import MaterialSimulationWizard as base


class GulpWizard(base):
    
    
    class Inventory(base.Inventory):
        
        import pyre.inventory
        
        pass
    
   

        

    def configureSimulation(self, director):
        type = self.inventory.type = 'gulpsimulations'

        simulation = self._getSimulation(director)
        id = self.inventory.id = simulation.id

        # make sure material is defined
        if not self._materialDefinedForSimulation(simulation, director):
            return self._needMaterialAlert(director)
        
        try:
            page = director.retrieveSecurePage( 'genericMaterialSimulationWizard' )
        except AuthenticationError, err:
            return err.page
        
        main = page._body._content._main
        document = main.document(title='Atomic-level Simulation with Forcefields' )
        document.byline = '<a href="http://danse.us">DANSE</a>'    
        
        formcomponent = self.retrieveFormToShow( 'gulp')
        formcomponent.director = director
        # build the form form
        form = document.form(name='', action=director.cgihome)
        # specify action
        action = actionRequireAuthentication(          
            actor = 'gulpsimulationwizard', 
            sentry = director.sentry,
            routine = 'verifySimulation',
            id=id, 
            type=type,
            arguments = {'form-received': formcomponent.name },
            )
        from vnf.weaver import action_formfields
        action_formfields( action, form )
        # expand the form with fields of the data object that is being edited
        formcomponent.expand( form , materialSimulationId = id, matterId = simulation.matter.id)
        next = form.control(name='submit',type="submit", value="next")
        return page 
    
#    def verifySimulation(self, director):
#        try:
#            page = self._retrievePage(director)
#        except AuthenticationError, err:
#            return err.page
#        # eventually have some sort of gulp simulation verification
#
#        # this is a bit weird. the type is the table name. but usually
#        # table name has a 's' at the end, and it is not desirable.
#        # the following code takes the table class name.
#        table = director.clerk._getTable('sqefrommd')
#        
#        sqefrommd = director.clerk.newOwnedObject(table)
#        
#        actor = 'sqefrommdwizard'
#        routine = 'configureSimulation'
#        return director.redirect(actor, routine, id=sqefrommd.id, type=sqefrommd.name)
    
    def verifySimulation(self, director):
        try:
            page = self._retrievePage(director)
        except AuthenticationError, err:
            return err.page
        # eventually have some sort of gulp simulation verification?
        #self.createGulpInputs(director)
        
        #get javagulp cgi inputs and use them to update simulation and create job
        simulation = self._getSimulation(director)
        
        # process new information
        
        # go to create job screen
        return self.createJob(director)
   
    def createGulpInputs(self, director):
        # vasp computation configurations
        simulation = self._getSimulation(director)

        # make a copy of this computation
        computation = director.clerk.deepcopy(simulation)
        # change description
        computation.short_description = 'generate vasp inputs for computation %s' \
                                        % simulation.id

        # make sure this computation only generate input files
        computation.generateInputsOnly = True
        director.clerk.updateRecord(computation)
        
        # create a job for this computation
        from vnf.components.Job import new_job
        job = new_job(director)

        # connect this job to the computation
        computation.job = job
        director.clerk.updateRecord(computation)
        job.computation = computation
        director.clerk.updateRecord(job)
        
        # submit this job
        from vnf.components.Job import submit
        submit(job, director)

        # the server this job was submitted to
        server = job.server.dereference(director.clerk.db)
        
        #  check whether input files were generated
        #  try 10 times
        count = 0; gotfiles = 0
        while count<10:
            count += 1
            try:
                director.dds.remember(job, files=files, server=server)
                gotfiles = 1
                break
            except:
                time.sleep(1)
                continue
        if not gotfiles:
            raise RuntimeError, 'unable to generate VASP input files'

        #  copy them to the vnf server
        director.dds.make_available(job, files=files)

        d = {}
        for f in files:
            d[f] = open(director.dds.abspath(job, f)).read()
            continue

        # !!!should delete the computation that is only for
        # creating the vasp inputs here!!!
        return d
   

    pass # end of GulpWizard


def actor():
    return GulpWizard('gulpsimulationwizard')


# version
__id__ = "$Id$"

# End of file 
