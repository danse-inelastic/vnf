#!/usr/bin/env python
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#                               Alex Dementsov
#                      California Institute of Technology
#                        (C) 2009  All Rights Reserved
#
# {LicenseText}
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#

from vnf.dom.QEJob import QEJob
from vnfb.utils.qeutils import makedirs, writefile
from vnfb.utils.qeconst import STATES
from vnfb.utils.qeutils import packname, unpackname

import os
from luban.content import select
from luban.content.Paragraph import Paragraph
from luban.content.Document import Document
from luban.content import load
from luban.content.Link import Link
from luban.content.Splitter import Splitter
from luban.content.FormSelectorField import FormSelectorField
from luban.content.Plot2D import Plot2D

# Variable that should be set in envs.sh
#EXPORT_ROOT = os.environ.get('EXPORT_ROOT')

import luban.content as lc
from luban.components.AuthorizedActor import AuthorizedActor as base

class Actor(base):

    class Inventory(base.Inventory):
        import pyre.inventory
        id          = pyre.inventory.str('id', default='')  # Simulation Id
        taskid      = pyre.inventory.str('taskid', default='')


    def default(self, director):
        "Not implemented"
        pass
    

    def submit(self, director):
        """
        Submit simulation job
        The process of submission of simulation includes the following steps:
        1. Store configuration inputs to local disk storage
        2. Copy files to the computational cluster
        3. Submit Job
        """
        self._createJob(director)
        #self._storeFiles(director)
        #self._moveFiles(director, inputs)
        #self._scheduleJob(director, inputs)

        return load(actor="material_simulations/espresso/sim-view",
                    id=self.id)


    def _createJob(self, director):
        params  = {"taskid":        self.taskid,
                   "serverid":      "server001",     # -> take from QESimulations
                   "status":        "Preparing",
                   "creator":        director.sentry.username,
                   "numberprocessors":   8 # -> take from QESettings
                   }
        job  = QEJob()
        job.setDirector(director)
        job.createRecord(params)

    # creator, status, numberprocessors, taskid, serverid

    def _storeFiles(self, director):
        """TEMP SOLUTION: Stores files from configuration input strings """
        self._storeConfigurations(director)
        self._generateRunScript()
        self._prepareFiles()


    def _storeConfigurations(self, director):
        "Store Configuration files"
        inputs  = director.clerk.getQEConfigurations(where = "taskid='%s'" % self.taskid)
        dds     = director.dds
        for input in inputs:
            filename    = dds.abspath(input, filename = input.filename)
            dds.remember(input, input.filename)     # Change object and filename?
            self._writeContent(dds, input, filename, input.text)


#    def _storeSettings(self, director):
#        # Store Settings files. I don't really need to store to files.
#        # Instead use data to create run.sh
#        settings  = director.clerk.getQESettings(where = "simulationid='%s'" % self.id)
#        dds     = director.dds
#        for s in settings:
#            filename    = dds.abspath(s, filename = s.sname)
#            dds.remember(s, s.sname)     # Change object and filename?
#            self._writeContent(dds, input, filename, input.text)


    def _writeContent(self, dds, record, filename, content):
        """Writes content of the configuration input to file"""
        path    = dds.abspath(record)
        makedirs(path)
        writefile(filename, content)


    def _moveFiles(self, director, inputs):
        """
        Moves files from local server to the computational cluster.
        Files that need to be moved:
            - Configuration inputs
            - Simulation Settings
            - run.sh script (generate it first)
        """
        dds     = director.dds
        server  = director.clerk.getServers(id='server001') # Hardcoded

        # See also: submitjob.odb

        #input   = inputs[0]
        #files   = []
        #files.append(self.files[0])
        dds.make_available(inputs[0], server=server, files=['PW',]) #self.files[0]

        # Why job? - Can be any table instead. How to get server?
#        server = clerk.dereference(job.server)
#        director.declareProgress(0.5, 'Preparing: transfering job to the server %s ...' % server.short_description)
#        dds.make_available(job, server=server, files=files)


    def _scheduleJob(self, director, inputs):
        # FIXME
        dds     = director.dds
        from vnfb.utils.qescheduler import schedule
        schedule(inputs[0], director)


    def retrieveStatus(self, director):
#        inputs  = director.clerk.getQEConfigurations(where = "simulationid='%s'" % self.id)
#        input   = inputs[0]
#
#        return self._packingInProgress(director, input)
        return self._retrieveResults(director)


    def _retrieveResults(self, director):
        inputs  = director.clerk.getQEConfigurations(where = "simulationid='%s'" % self.id)
        input   = inputs[0]

        from vnf.applications.PackJobDir import PackJobDir
        PTRFILEEXT = PackJobDir.PTRFILEEXT
        ptrfilepath = '.'.join( [director.dds.abspath(input), PTRFILEEXT] )

        # if pointer file does not exists, need to start packing
        if not os.path.exists(ptrfilepath):
            return self._startPacking(director, input)

        # if packing is in process, say that
        s = open(ptrfilepath).read()
        if s == PackJobDir.PACKINGINPROCESS:
            return self._packingInProgress(director, input)


        server      = server  = director.clerk.getServers(id='server001')
        jobmtime    = director.dds.getmtime(input, server = server)
        ptrmtime    = os.path.getmtime(ptrfilepath)
        if jobmtime > ptrmtime + 60*3: # 60*3 -- give 3 minute of delay
            # if job directory is newer than the bar ball, pack again
            return self._startPacking(director, input)

        link    = Link(label="Downloaded", Class="action-link",
                       onclick=load(actor      = "material_simulations/espresso/sim-view",
                                     id         = self.id)
                      )

        return select(id='results-link').replaceContent(link)


    def _startPacking(self, director, input):
        from vnf.components.Job import pack
        pack(input, director, debug=False)

        return self._packingInProgress(director, input)


    def _packingInProgress(self, director, input):
        link    = Link(label="Packing", Class="action-link",
                       onclick=load(actor      = "material_simulations/espresso/sim-view",
                                     id         = self.id)
                      )

        return select(id='results-link').replaceContent(link)



    def formError(self, errors):
        return [
                select(id='%s-error-area' % key).replaceContent(value)
                    for key, value in errors.iteritems()
                ]


    def __init__(self):
        super(Actor, self).__init__(name='jobs/submit')

        return


    def _configure(self):
        super(Actor, self)._configure()
        self.id         = self.inventory.id
        self.taskid     = self.inventory.taskid


    def _init(self):
        super(Actor, self)._init()
        return

def actor():
    return Actor()


__date__ = "$Nov 4, 2009 9:27:51 AM$"


# ********************** DEAD CODE ***********************

        #self.files  = []
        #self.files.append(input.filename)       # ??? Relative path, e.g. ni.scf.in
        #filename    = dds.abspath(input, filename = "run.sh")
        #content     =
        #self._writeContent(dds, input, filename, content)
        # FIXME
        #for f in self.files:
        # Should be local filename
        #dds.remember(inputs[0], 'PW')
            # for f in files: dds.remember(job, f) #?


# ********************** DEAD CODE ***********************

#    def submit(self, director):
#        self.verify()
#        self.createRecord(director)
#        self.runSimulation(director)
#
#        return load(actor='jobs/submitted', routine='link')
#
#
#    def verify(self):
#        """Checks if all the components available to run the simulation"""
#        pass
#
#    def content(self, director):
#        document = Document(title='Job Submitted')
#        document.add(Paragraph(text="Your jobs was successfully submitted!"))
#        document.add(Link(label="All jobs", Class="action-link", onclick=load(actor="jobs/index", routine="link")))
#
#        return document
#
#
#    def pathlist(self, director):
#        self.pathlist = [("Home","greet","link"),
#                         ("Jobs", "jobs/index", "link"),
#                         ("Submitted", None, None) ]
#
#        return self.pathlist
#
#
#    # Create Job
#    def createRecord(self, director):
#        params  = { "userId": 1, "simulationId": self.id,
#                    "status": STATES["C"], "exitCode": 0,
#                    "numberProcessors": 8}
#        job     = Job()
#        job.createRecord(director, params)
#
##        package = PACKAGES[int(self.package)]
##        simtype = SIMULATIONS[int(self.simtype)]
##
##        params  = {"sname": self.sname, "package": package,
##                   "type": simtype, "description": self.description,
##                   "formula": self.formula, "isFavorite": True}
##        sim     = Simulation()
##        sim.createRecord(director, params)
#
#
#
#    # Temp methods for running simulation
#    def runSimulation(self, director):
#
#        self.runPWSimulation(director)
#        self.runPW_DOS(director)
#        self.createPWPlot(director)
#
#
#    # Run PW simulation
#    def runPWSimulation(self, director):
#        config      = director.clerk.getConfigurations(id=1)
#        configtext  = config.text
#
#        #infile  = EXPORT_ROOT + "/content/data/ni.scf.in" # Uses database
#        outfile = EXPORT_ROOT + "/output/ni.scf.out"
#
#        from vinil.utils import pw
#        configmod = self.setPWConfig(config=configtext)
#        pw.runPWSimulation(outfile, config=configmod)
#
#    # Sets pseudo_dir and outdir (hardcoded) and saves to the same file.
#    def setPWConfig(self, filename=None, config=None):
#        from vinil.utils.parser.qeinput import QEInput
#        qe = QEInput(filename, config)
#        qe.parse()
#        pd = qe.namelist('control')
#
#        pseudo_dir  = EXPORT_ROOT + "/content/data/"
#        outdir      = EXPORT_ROOT + "/content/temp/"
#        pd.editParam('pseudo_dir', "'%s'" % pseudo_dir)
#        pd.editParam('outdir',     "'%s'" % outdir)
#
#        if filename:
#            qe.save()
#            return
#
#        if config:
#            return qe.toString()
#
#
#    # Find electron DOS
#    def runPW_DOS(self, director):
#        config      = director.clerk.getConfigurations(id=4)
#        configtext  = config.text
#
#        #infile  = EXPORT_ROOT + "/content/data/ni.scf.dos.in" # Uses database
#
#        configmod = self.setPW_DOSConfig(config=configtext)
#        from vinil.utils import dos
#        dos.runPW_DOS(config=configmod)
#
#
#    def setPW_DOSConfig(self, filename=None, config=None):
#        from vinil.utils.parser.qeinput import QEInput
#        qe = QEInput(filename, config, type='dos')
#        qe.parse()
#        pd = qe.namelist('inputpp')
#
#        outdir      = EXPORT_ROOT + "/content/temp/"
#        fildos      = EXPORT_ROOT + "/output/ni.scf.dos.out"
#
#        pd.editParam('outdir', "'%s'" % outdir)
#        pd.editParam('fildos', "'%s'" % fildos)
#
#        if filename:
#            qe.save()
#            return
#
#        if config:
#            return qe.toString()
#
#
#
#    # Plot electron DOS
#    def createPWPlot(self, director):
#        infile      = EXPORT_ROOT + "/output/ni.scf.dos.out"
#        imagefile   = EXPORT_ROOT + "/html/images/plots/ni_scf_dos.png"
#
#        from vinil.utils import plot
#        plot.createPWPlot(infile, imagefile)
