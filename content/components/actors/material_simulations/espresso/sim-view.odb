#!/usr/bin/env python
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#                               Alex Dementsov
#                      California Institute of Technology
#                        (C) 2009  All Rights Reserved
#
# {LicenseText}
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#

import os

from vnfb.utils.qeutils import stamp2date, makedirs
from vnfb.utils.qetasks import QETasks
from vnfb.utils.qegrid import QEGrid
from vnfb.utils.qeparams import QEParams
from vnfb.utils.qeserver import QEServer
from vnfb.utils.qeconst import SIMCHAINS

#from luban.content.Splitter import Splitter

from luban.content import select
from luban.content.Paragraph import Paragraph
from luban.content.Document import Document
from luban.content import load
from luban.content.Link import Link

import luban.content as lc
from luban.components.AuthorizedActor import AuthorizedActor as base
class Actor(base):

    class Inventory(base.Inventory):
        import pyre.inventory
        id      = pyre.inventory.str('id', default='')      # Simulation Id


    def default(self, director):
        return select(id='main-display-area').replaceContent(self.content(director))


    def content(self, director):
        sim         = director.clerk.getQESimulations(id=self.id)
        self.type   = sim.type
        
        def viewIndicator(director):
            path = []
            path.append(('Simulations ', load(actor='materialsimulation')))
             # Stub, should filter by simulation type
            path.append(('Quantum Espresso ', load(actor='materialsimulation')))
            path.append(self.id)

            return director.retrieveVisual('view-indicator', path=path)

        doc         = lc.document(title   = 'Simulation Name: %s' % sim.sname)
        splitter    = doc.splitter(orientation="vertical")
        sA          = splitter.section()
        sA.add(viewIndicator(director))
        
        sC          = splitter.section(id="qe-section-actions")
        self._showActions(sC)

        # Area for errors
        splitter.section(id="input-error-area") # ?

        sB          = splitter.section()

        table       = QEGrid(lc.grid(Class = "qe-table"))
        sB.add(table.grid())
        self._showSimulationInfo(table, sim)
        self._showSettings(director, table)
        self._showServer(director, table)
        self._showResults(director, table)
        self._showTasks(director, splitter, sim.type)

        # Should go after all of the rows are added!
        table.setColumnStyle(0, "qe-cell-param")    
        
        return doc

    def _showActions(self, section):
        section.add(lc.link(label="Refresh",
                            Class="qe-action-refresh",
                            onclick = load(actor='material_simulations/espresso/sim-view',
                                           id=self.id)))
        section.add(lc.link(label="New",
                            Class="qe-action-new",
                            onclick = load(actor='material_simulations/espresso/sim-edit',
                                           id=self.id)))

        section.add(lc.link(label="Edit",
                            Class="qe-action-edit",
                            onclick = load(actor='material_simulations/espresso/sim-edit',
                                           id=self.id)))
        section.add(lc.link(label="Clone",
                            Class="qe-action-clone",
                            onclick = load(actor='material_simulations/espresso/sim-clone',
                                           id=self.id)))
        section.add(lc.link(label="Analyze",
                            Class="qe-action-analyze",
                            onclick = load(actor='material_simulations/espresso/sim-edit',
                                           id=self.id)))
        section.add(lc.link(label="Delete",
                              Class="qe-action-delete",
                              onclick = load(actor='material_simulations/espresso/sim-delete',
                              id=self.id)))

        section.add(lc.document(Class="clear-both"))


    def _showSimulationInfo(self, table, sim):
        """Shows simulation data"""
        if sim: # ?
            table.addRow(('Description: ', sim.short_description))
            table.addRow(('Type: ', sim.type))
            table.addRow(('Package: ', sim.package))
            table.addRow(('Label: ', sim.label))
            table.addRow(('Time Created: ', stamp2date(sim.date)))


    def _showSettings(self, director, table):
        params  = QEParams(director)
        link    = params.getLink(self.id)

        table.addRow(("Simulation Settings: ", link))


    def _showServer(self, director, table):
        server  = QEServer(director)
        link    = server.getLink(self.id)

        table.addRow(("Server: ", link))


    def _showResults(self, director, table):
        "STUB: Returns link to tar file for download. "
        celldoc     = Document(Class="display-inline")
        cell        = Document(id="results-link")   # Container for tar link
        celldoc.add(cell)

        tarlink     = Paragraph(text="None")
        #link    = self._retrieveResults(director)

        # Change actor
        check    = Link(label="Check", id="qe-check-results", #Class="padding-left-20",
                       onclick=load(actor       = "material_simulations/espresso/sim-view",
                                    routine     = "retrieveStatus",
                                    id          = self.id)
                      )

        analyze  = Link(label="Analyze", id="qe-analyze-results", #Class="padding-left-20",
                       onclick=load(actor       = "material_simulations/espresso/results",
                                    id          = self.id)
                      )

        cell.add(tarlink)
        celldoc.add(check)
        celldoc.add(analyze)

        table.addRow(("Results: ", celldoc))


    def _showTasks(self, director, splitter, type):
        """Shows chain of configuration files"""
        # Show simulation tasks section
        sC          = splitter.section(id="qe-tasks-label")
        sC.add(Paragraph(text="Simulation Tasks", Class="qe-section-inline"))
        sC.add(lc.link(label="Refresh Status", id = "action-refresh-status",
                         onclick = load(actor='material_simulations/espresso/sim-view',
                                        id=self.id)
                        ))
        sC.add(lc.document(Class="clear-both"))

        # Show refresh status button
#        sR          = splitter.section()
#        sR.add(lc.button(label="Refresh Status",
#                         onclick = load(actor='material_simulations/espresso/sim-view',
#                                        id=self.id)
#                        ))
#        sR.add(lc.document(Class="clear-both"))

        # Show tasks table
        taskstable   = QETasks(director, type)
        sT          = splitter.section()
        sT.add(taskstable.tasks(self.id))
        





# Move to task
#    def showJobs(self, director, table):
#        """Adds list of job ids to the document"""
#
#        jobsdoc = Document(Class="display-inline")
#        joblist  = self.jobs(director)
#
#        if len(joblist) != 0:
#            for job in joblist:
#                jobsdoc.add(Link(label=job.id, Class="action-link",
#                                 onclick=load(actor="jobs/view",
#                                 routine="link", id=job.id))
#                            )
#        else:
#            jobsdoc.add(Paragraph(text="None", Class="action-link"))
#
#        addRow(table, "Jobs: ", jobsdoc)


#    # TODO: Should be separate for each task
#    def _showSubmit(self, document):
#        """Adds References"""
#        #document.add(Document(Class="clear-both"))   # Empty document
#        #refsdoc = Document(Class="display-block")
#        refsdoc.add(lc.button(label="Submit to Queue", onclick=load(actor="material_simulations/espresso/sim-view",
#                                                               routine="checkSubmit",
#                                                               id=self.id)))
#        document.add(refsdoc)
#        document.add(lc.document(Class="clear-both"))


    def checkSubmit(self, director):
        """Checks if the simulation can be submitted to jobs queue"""
        errors  = {}
        self._checkInputs(director, errors)
        
        # Check settings # Not sure if I need it now
        # If check failed, go to error page (with link "Go Back")
        #return load(actor="jobs/submitted", routine="submit", id=self.id)
        if errors:
            return self.formError(errors)


        return load(actor="material_simulations/espresso/sim-view",
                   routine="submit",
                   id=self.id)


    # Refactor later on
    def submit(self, director):
        """
        The process of submission of simulation includes the following steps:
        1. Store configuration inputs to local disk storage
        2. Copy files to the computational cluster
        3. 
        """

        inputs  = director.clerk.getQEConfigurations(where = "simulationid='%s'" % self.id)

        self._storeFiles(director, inputs)
        self._moveFiles(director, inputs)
        self._scheduleJob(director, inputs)

        return load(actor="materialsimulation")

#        return load(actor="material_simulations/espresso/sim-view",
#                   id=self.id)

    def _checkInputs(self, director, errors):
        """Checks config inputs"""
        sim     = director.clerk.getQESimulations(id = self.id)
        inputs  = director.clerk.getQEConfigurations(where = "simulationid='%s'" % self.id)
        chain   = SIMCHAINS[sim.type]
        if not self._isComplete(chain, inputs):
            errors['input']  = "Error: One of the configuration inputs are missing"
            return


    def _isComplete(self, chain, inputs):
        test    = [0 for i in range(len(chain))]
        types   = self._getInputTypes(inputs)

        for i in range(len(types)):    # Check if inputs has all the values from chain list
            for j in range(len(chain)):
                if types[i] == chain[j]:
                    test[j] = 1

        if test.count(0) == 0:  # No zeros left, then set is complete
            return True

        return False


    def _getInputTypes(self, inputs):
        """Converts configuration entries to """
        types   = []
        for i in inputs:
            if i.text != '':
                types.append(i.type)

        return types


    def _storeFiles(self, director, inputs):
        """Temp solution. Stores files from configuration input strings """
        
        dds = director.dds
        for input in inputs:
            filename    = dds.abspath(input, filename = input.type)
            self.files.append(input.type) # Relative path, e.g. ni.scf.in

            # for f in files: dds.remember(job, f) #?
            self._writeContent(dds, input, filename, input.text)

        #filename    = dds.abspath(input, filename = "run.sh")
        #content     =
        #self._writeContent(dds, input, filename, content)
        # FIXME
        #for f in self.files:
        # Should be local filename
        dds.remember(inputs[0], 'PW')


    def _writeContent(self, dds, record, filename, content):
        """Writes content of the configuration input to file"""
        path    = dds.abspath(record)
        makedirs(path)
        open(filename, 'w').write(content)


    def _moveFiles(self, director, inputs):
        dds     = director.dds
        server  = director.clerk.getServers(id='server001') # Hardcoded

        # See also: submitjob.odb

        #input   = inputs[0]
        #files   = []
        #files.append(self.files[0])
        dds.make_available(inputs[0], server=server, files=['PW',]) #self.files[0]

        # Why job? - Can be any table instead. How to get server?
#        server = clerk.dereference(job.server)
#        director.declareProgress(0.5, 'Preparing: transfering job to the server %s ...' % server.short_description)
#        dds.make_available(job, server=server, files=files)


    def _scheduleJob(self, director, inputs):
        # FIXME
        dds     = director.dds
        from vnfb.utils.qescheduler import schedule
        schedule(inputs[0], director)


    def retrieveStatus(self, director):
#        inputs  = director.clerk.getQEConfigurations(where = "simulationid='%s'" % self.id)
#        input   = inputs[0]
#
#        return self._packingInProgress(director, input)
        return self._retrieveResults(director)


    def _retrieveResults(self, director):
        inputs  = director.clerk.getQEConfigurations(where = "simulationid='%s'" % self.id)
        input   = inputs[0]
        
        from vnf.applications.PackJobDir import PackJobDir
        PTRFILEEXT = PackJobDir.PTRFILEEXT
        ptrfilepath = '.'.join( [director.dds.abspath(input), PTRFILEEXT] )
        
        # if pointer file does not exists, need to start packing
        if not os.path.exists(ptrfilepath):
            return self._startPacking(director, input)

        # if packing is in process, say that
        s = open(ptrfilepath).read()
        if s == PackJobDir.PACKINGINPROCESS:
            return self._packingInProgress(director, input)


        server      = server  = director.clerk.getServers(id='server001')
        jobmtime    = director.dds.getmtime(input, server = server)
        ptrmtime    = os.path.getmtime(ptrfilepath)
        if jobmtime > ptrmtime + 60*3: # 60*3 -- give 3 minute of delay
            # if job directory is newer than the bar ball, pack again
            return self._startPacking(director, input)

        link    = Link(label="Downloaded", Class="action-link",
                       onclick=load(actor      = "material_simulations/espresso/sim-view",
                                     id         = self.id)
                      )

        return select(id='results-link').replaceContent(link)


    def _startPacking(self, director, input):
        from vnf.components.Job import pack
        pack(input, director, debug=False)

        return self._packingInProgress(director, input)


    def _packingInProgress(self, director, input):
        link    = Link(label="Packing", Class="action-link",
                       onclick=load(actor      = "material_simulations/espresso/sim-view",
                                     id         = self.id)
                      )

        return select(id='results-link').replaceContent(link)



    def formError(self, errors):
        return [
                select(id='%s-error-area' % key).replaceContent(value)
                    for key, value in errors.iteritems()
                ]


    def jobs(self, director):
        joblist = []
        jobs = director.clerk.getQEJobs(where="simulationid='%s'" % self.id)
        for job in jobs:
            if job:
                joblist.append(job)

        return joblist



    def __init__(self):
        super(Actor, self).__init__(name='material_simulations/espresso/sim-view')
        self.files  = [] # Temp

        return


    def _configure(self):
        super(Actor, self)._configure()
        self.id = self.inventory.id
        return


    def _init(self):
        super(Actor, self)._init()
        return

def actor():
    return Actor()


__date__ = "$Nov 2, 2009 3:15:35 PM$"

