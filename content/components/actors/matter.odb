#!/usr/bin/env python
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#                                 Jiao Lin
#                      California Institute of Technology
#                      (C) 2006-2009  All Rights Reserved
#
# {LicenseText}
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#


from luban.content import load, select, alert

from luban.content.Button import Button
from luban.content.Link import Link
from luban.content.Paragraph import Paragraph
from luban.content.Document import Document


from vnfb.components.MasterTable import FilterSyntaxError, MasterTableActor as base


class Actor(base):


    class Inventory(base.Inventory):

        import pyre.inventory

        id = pyre.inventory.str('id')
        type = pyre.inventory.str('type')
        description = pyre.inventory.str('description')


    def default(self, director):
        return self.showListView(director)


    def replaceBodyFrameWithMatterList(self, director):
        body_frame = select(id='body-frame')
        body_skeleton = director.retrieveVisual('body-skeleton')
        main_display_area = body_skeleton.find(id='main-display-area')

        try:
            matterlist = self.createListView(director)
        except FilterSyntaxError, msg:
            return alert('filter syntax error: %s' % msg)
            
        main_display_area.add(matterlist)

        material_portlet = body_skeleton.find(id='main-portlet-my-materials')
        material_portlet.selected = 1
        
        return body_frame.replaceContent(body_skeleton)


    def showListView(self, director):
        try:
            view = self.createListView(director)
        except FilterSyntaxError, msg:
            return alert('filter syntax error: %s' % msg)
        return [
            select(id='main-display-area').replaceContent(view),
            ]
            
            
    def createListView(self, director):
        from vnfb.components.MasterTable import MasterTableFactory, filtercompiler
        def countrecords(filter):
            return self._countMatters(director, filter)
        def createtable(order_by, reverse_order, slice, filter):
            return self.createMatterTable(
                director,
                order_by=order_by,
                reverse_order=reverse_order,
                slice=slice,
                filter=filter)
        compilefilter = filtercompiler(columns, measure2dbcol)

        factory = MasterTableFactory(
            self.name, countrecords, createtable, compilefilter, filtercols)

        order_by = self.inventory.order_by
        reverse_order = self.inventory.reverse_order
        number_records_per_page = self.inventory.number_records_per_page
        page_number = self.inventory.page_number

        filter_expr = self.inventory.filter_expr
        filter_key = filtercols[self.inventory.filter_key]
        filter_value = self.inventory.filter_value
        
        tableview = factory.create(
            order_by=order_by,
            reverse_order=reverse_order,
            filter_expr=filter_expr, filter_key=filter_key, filter_value=filter_value,
            number_records_per_page=number_records_per_page,
            page_number=page_number)

        # add new button
        toolbar = tableview.find(id='matter-table-toolbar-changeview')
        toolbar.add(Paragraph(text='|', Class='splitter'))
        #
        button = Button(label='New', tip='create new matter', icon='new.png')
        toolbar.add(button)
        button.onclick = load(actor='matter', routine='new')
        
        return tableview
    
        
    def createMatterTable(self, director, order_by=None, reverse_order=None, slice=None, filter=None):
        matters = self._getMatters(director, filter=filter, order_by=order_by, reverse_order=reverse_order, slice=slice)

        cols = columns
        args = matters, cols, director
        thetable = director.retrieveComponent(
            'matter-table',
            factory="visual", args=args,
            vault=['visuals'])
        thetable.oncellchanged = select(element=thetable).notify(
            event='row-changed', actor='mattertable', routine='processRowChange')
        return thetable
    

    def view(self, director):
        matter = self._getMatter(director)
        
        from luban.content.Page import Page
        page = Page(title='Material %s' % matter.short_description)

        document = page.document(id='main-display-area')
        
        view = self.createView(director)
        document.add(view)
        
        return page


    def showMaterialView(self, director):
        view = self.createView(director)
        return select(id='main-display-area').replaceContent(view)
    
        
    def createView(self, director):
        visual = director.retrieveVisual('matter')

        matter = self._getMatter(director)
        name =  matter.short_description or matter.id
        text = '<p>Matter\ <a>%s</a></p>' % name
        from luban.content.HtmlDocument import HtmlDocument
        html = HtmlDocument(text=text)
        visual.find(id='matterdoc-title').add(html)
        if not matter.short_description:
            visual.find(id='matterdoc-title-extra').add(
                self.createMatterDescriptionInputControl(director))
        
        matterviewdoc = visual.find(id='matterviewdoc')
        descriptiondoc = self.createDescriptionDoc(director)
        matterviewdoc.add(descriptiondoc)

        oldmatsimtab = visual.find(id='oldmatsimtab')
        simstablecontainer = oldmatsimtab.document(id='matsimstablecontainer')
        simstable = self.createSimsTable(director)
        simstablecontainer.add(simstable)

        newmatsimtab = visual.find(id='newmatsimtab')
        newmatsimscontainer = newmatsimtab.document(id='newmatsimscontainer')
        newsims = self.createNewSimButtons(director)
        newmatsimscontainer.add(newsims)
        return visual


    def createMatterDescriptionInputControl(self, director):
        from luban.content.Splitter import Splitter
        from luban.content.Link import Link
        from luban.content.FormTextField import FormTextField
        doc = Splitter(id='matter-description-editor-container')

        left = doc.section()
        label = 'To give this material a name, click here'
        link = Link(label=label, id='matterdoc-change-matter-name-link')
        left.add(link)

        right = doc.section()
        field = FormTextField(
            id = 'matter-description-input',
            hidden = 1,
            )
        field.onchange = load(
            actor='matter', routine='changeDescriptionAndUpdateMatterView',
            id = self.inventory.id, type = self.inventory.type,
            description = select(element=field).formfield('getValue')
            )
        right.add(field)

        left.onclick = [select(element=link).hide(), select(element=field).show()]
        return doc


    def changeDescriptionAndUpdateMatterView(self, director):
        self.changeDescription(director)
        return self.showMaterialView(director)


    def changeDescription(self, director):
        matter = self._getMatter(director)
        matter.short_description = self.inventory.description
        director.clerk.updateRecordWithID(matter)
        return


    def createNewSimButtons(self, director):
        matter = self._getMatter(director)
        
        doc = Document()

        # should be handled by resource manager
        icons = {
            }
        
        simtables = simulationTables()
        def _(table):
            #doc = Document()
            name = table.__name__
            label = table.DESCRIPTION
            icon = icons.get(name)
            if not icon:
                icon = '%s.png' % name
            icon = 'material_simulations/%s' % icon
            actor = 'material_simulations/%s' % (name.lower(), )
            button = Button(
                label=label, icon=icon, id='new-simulation-%s-button' % name,
                tip = '\n '.join(table.LONG_DESCRIPTION),
                onclick=load(
                    actor=actor, routine='new',
                    matter_type=matter.name, matter_id=matter.id)
                )
            return button

        buttons = map(_, simtables)
        map(doc.add, buttons)
        return doc


    def createSimsTable(self, director):
        matter = self._getMatter(director)
        #return director.redirect(
        #    actor='materialsimulation',
        #    routine='createTable',
        #    filter="matsim.matter_gptr='%s'" % matter.globalpointer.id,
        #    )
        sims = getallsimulations(matter=matter, db=director.clerk.db)

        if not sims:
            text = ['There is no simulation for this material. Please create a new simulation. To start, click the "Create new simulation" tab']
            return Document().paragraph(text=text)

        args = sims, ['id', 'description', 'type', 'date',], director
        #return table(*args)
        thetable = director.retrieveComponent(
            'materialsimulation-table',
            factory="visual", args=args,
            vault=['visuals'])

        return thetable


    def createDescriptionDoc(self, director):
        matter = self._getMatter(director)

        # cartesian lattice
        cl = matter.cartesian_lattice
        import numpy
        cl = numpy.array(cl)
        cl.shape = 3,3

        # atoms
        symbols = matter.atom_symbols
        n = len(symbols)
        coords = matter.fractional_coordinates
        coords = numpy.array(coords)
        coords.shape = n, 3
        atoms = [
            ' * %s: %s' % (symbol, coord)
            for symbol, coord in zip(symbols, coords)
            ]
        atoms = '\n'.join(atoms)

        subs = {
            'name': matter.short_description,
            'a': cl[0],
            'b': cl[1],
            'c': cl[2],
            'atoms': atoms,
            }
        subs['namebar'] = '='*len(subs['name'])
        # %(name)s
        # %(namebar)s
        description = '''

Lattice
"""""""

 * a = %(a)s
 * b = %(b)s
 * c = %(c)s


Atoms
"""""

%(atoms)s

        ''' % subs

        from luban.content.ReSTDocument import ReSTDocument
        descriptiondoc = ReSTDocument(text = description.split('\b'))
        
        return descriptiondoc


    def test(self, director):
        from luban.content.Page import Page
        page = Page(title='test')
        visual = director.retrieveVisual('matter')
        page.add(visual)
        return page
    
    
    def __init__(self, name='matter'):
        super(Actor, self).__init__(name)
        return

    # db access
    def _getMatter(self, director):
        type = self.inventory.type
        id = self.inventory.id
        return director.clerk.getRecordByID(type, id)


    def _countMatters(self, director, filter=None):
        from vnf.dom import mattertables
        tables = mattertables()
        db = director.clerk.db

        qf = lambda table: matterQuery(table, db, filter=filter)
        qs = map(qf, tables)
        
        q = sqlalchemy.union_all(*qs)
        return q.alias('tocount').count().execute().fetchone()[0]


    def _getMatters(self, director, filter=None, order_by=None, reverse_order=None, slice=None):
        # this implementation does not work when order_by=Type
        self._debug.log('filter: %r, order_by: %r, slice: %r' % (filter, order_by, slice))
        from vnf.dom import mattertables
        tables = mattertables()

        db = director.clerk.db
        qf = lambda table: matterQuery(table, db, filter=filter)

        qs = map(qf, tables)
        q = sqlalchemy.union_all(*qs)

        if order_by:
            q = q.order_by(order_by)
        if slice:
            if reverse_order:
                n = self._countMatters(director, filter=filter)
                slice = n-slice[1], n-slice[0]
            q = sqlalchemy.select(
                [q.alias('tmptoslice')],
                limit = slice[1]-slice[0],
                offset = slice[0])

        # only need gpointers to be returned
        q = q.alias('tmp')
        q1 = sqlalchemy.select(columns=['gptr'], from_obj=[q])

        #db._saengine.echo = True
        rows = q1.execute().fetchall()

        #and then map to records
        from dsaw.db.VersatileReference import vreference
        def _(row): return db.dereference(vreference(row[0]))
        
        ret = map(_, rows)
        if reverse_order:
            ret.reverse()
        return ret


columns = [ 'id', 'description', 'type', 'chemical_formula', 'created']
measure2dbcol = {
    'description': 'short_description',
    'created': 'date',
    }
filtercols = columns


from dsaw.db.VersatileReference import global_pointer
import sqlalchemy
def matterQuery(table, db, filter=None):
    sGP = db._tablemap.TableToSATable(global_pointer)
    st = db._tablemap.TableToSATable(table)
    q = sqlalchemy.select(
        [st.c.id.label('id'),
         st.c.short_description.label('short_description'),
         sGP.c.type.label('type'),
         st.c.date.label('date'),
         st.c.chemical_formula.label('chemical_formula'),
         st.c.globalpointer.label('gptr'),
         ],
        st.c.globalpointer==sGP.c.id,
        )
    if filter:
        q = sqlalchemy.select([q.alias('matter')], whereclause=filter)
    return q


def simulationTables():
    from vnf.dom import materialsimulationtables, materialmodelingtables
    tables = materialsimulationtables()# + materialmodelingtables()
    return tables


def getallsimulations(matter, db, **opts):
    tables = simulationTables()

    computations = []
    for table in tables:
        computations += matter.getReferences(db, table, 'matter', **opts)
        continue
    
    return computations


def actor(): return Actor()


# version
__id__ = "$Id$"

# End of file 

