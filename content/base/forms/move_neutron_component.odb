# -*- Python -*-
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#                                   Jiao Lin
#                      California Institute of Technology
#                        (C) 2009  All Rights Reserved
#
# {LicenseText}
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#



from vnf.components.Form import Form as base, formactor_action_prefix, \
     InputProcessingError


class Form(base):

    class Inventory(base.Inventory):

        import pyre.inventory

        x = pyre.inventory.str('x')
        y = pyre.inventory.str('y')
        z = pyre.inventory.str('z')

        rx = pyre.inventory.str('rx')
        ry = pyre.inventory.str('ry')
        rz = pyre.inventory.str('rz')

        reference = pyre.inventory.str('reference')

        pass # end of Inventory


    def __init__(self, name = None):
        if name is None:
            name = 'move_neutron_component'

        base.__init__(self, name)
        return


    def legend(self):
        return "Legend..."


    def expand(self, form, instrumentid=None, componentname=None, errors=None):
        '''expand an existing form with fields from this component'''

        director = self.director
        instrument = director.clerk.getInstrument(instrumentid)
        geometer = director.clerk.dereference(instrument.geometer)
        
        location = geometer[componentname]
        position = location.position
        orientation = location.orientation
        reference = location.reference_label
        
        prefix = formactor_action_prefix

        box = form.box()
        
        x = box.text(
            id='x', name='%s.x' % prefix, label='Position: (x)', 
            value = position[0])
        if errors and errors.get('x'): x.error = errors['x']
        
        y = box.text(
            id='y', name='%s.y' % prefix, label='(y)', 
            value = position[1])
        if errors and errors.get('y'): y.error = errors['y']
        
        z = box.text(
            id='z', name='%s.z' % prefix, label='(z)', 
            value = position[2])
        if errors and errors.get('z'): z.error = errors['z']

        
        box = form.box()
        
        rx = box.text(
            id='rx', name='%s.rx' % prefix, label='Orientation: (x)', 
            value = orientation[0])
        if errors and errors.get('rx'): rx.error = errors['rx']
        
        ry = box.text(
            id='ry', name='%s.ry' % prefix, label='(y)', 
            value = orientation[1])
        if errors and errors.get('ry'): ry.error = errors['ry']

        rz = box.text(
            id='rz', name='%s.rz' % prefix, label='(z)', 
            value = orientation[2])
        if errors and errors.get('rz'): rz.error = errors['rz']

        # reference
        references = ['absolute', 'previous'] + instrument.componentsequence
        entries = zip(references, references)
        selected = reference or 'absolute'
        selector = form.selector(
            id = 'reference_selector',
            name = '%s.reference' % prefix,
            entries = entries,
            label = 'Reference',
            selected = selected,
            )
        selector.tip = "Please select the reference point to which the position and orientation are specified."
        return


    def processUserInputs(self):
        errors = {}

        coords = ['x', 'y', 'z', 'rx', 'ry', 'rz']
        for coord in coords:
            if not isreal(getattr(self.inventory, coord)):
                errors[coord] = "Please input a real number"
            continue

        if errors:
            raise InputProcessingError, errors

        si = self.inventory
        position = map(float, (si.x, si.y, si.z))
        orientation = map(float, (si.rx, si.ry, si.rz))
        reference = si.reference

        return position, orientation, reference
    


def isreal(candidate):
    try:
        candidate = float(candidate)
    except:
        return False
    return True


def form(): return Form()

# version
__id__ = "$Id$"

# End of file 
